import unittest
import tempfile
import os
import io
import sys
from tree import mk, main


class TestPriemkaElki(unittest.TestCase):
    """Приемочные тесты для программы tree.py"""

    # ---------- ТЕСТЫ НА ФУНКЦИЮ mk ----------

    def test_one_floor_tree_structure(self):
        """Ёлка с 1 этажом: проверяем структуру"""
        result = mk(1).strip().splitlines()
        self.assertEqual(result[0].strip(), "W")            # верхушка
        self.assertIn("*", result[1])                       # звезда
        self.assertTrue(result[-1].strip().startswith("TT"))  # ствол

    def test_multiple_floors_have_symmetry(self):
        """Ёлка должна быть симметричной по горизонтали"""
        result = mk(4).splitlines()
        # проверим, что левая и правая половины зеркальны по длине
        widths = [len(line.rstrip("\n")) for line in result]
        self.assertTrue(all(abs(widths[i] - widths[-1]) < 2 for i in range(len(widths)//2)))

    def test_has_expected_number_of_lines(self):
        """Количество строк соответствует формуле"""
        floors = 5
        expected_lines = 1 + (2 * floors - 1) + 2  # W + листья + 2 основания
        result = mk(floors).splitlines()
        self.assertEqual(len(result), expected_lines)

    def test_invalid_floor_value_raises(self):
        """Если этажей меньше 1 — ошибка"""
        with self.assertRaises(ValueError):
            mk(0)

    def test_last_two_lines_are_trunk(self):
        """Проверка, что ствол всегда состоит из двух одинаковых строк"""
        result = mk(3).strip().splitlines()
        trunk1, trunk2 = result[-2:]
        self.assertEqual(trunk1.strip(), trunk2.strip())
        self.assertIn("TTTTT", trunk1)

    def test_at_symbols_alternate_sides(self):
        """Проверка чередования '@' слева и справа"""
        result = mk(4).splitlines()[2:-2]  # только листья
        ats = [line.strip().startswith("@") for line in result if "@" in line]
        # Должно чередоваться True/False
        for i in range(1, len(ats)):
            self.assertNotEqual(ats[i], ats[i - 1])

    def test_tree_is_centered(self):
        """Самая длинная строка (нижняя крона) длиннее всех остальных"""
        lines = mk(3).splitlines()
        lengths = [len(l) for l in lines]
        self.assertEqual(max(lengths), len(lines[-3]))  # последняя строка листвы — самая длинная

    def test_output_ends_with_newline(self):
        """Результат должен заканчиваться переводом строки"""
        out = mk(2)
        self.assertTrue(out.endswith("\n"))

    # ---------- ТЕСТЫ НА MAIN (CLI) ----------

    def test_main_creates_file(self):
        """main() должен создавать файл с елкой"""
        tmp = tempfile.NamedTemporaryFile(delete=False)
        tmp.close()
        argv = ["3", tmp.name]
        sys_stdout = io.StringIO()
        sys_stderr = io.StringIO()
        sys_stdout_old, sys_stderr_old = sys.stdout, sys.stderr
        sys.stdout, sys.stderr = sys_stdout, sys_stderr
        try:
            main(argv)
        finally:
            sys.stdout, sys.stderr = sys_stdout_old, sys_stderr_old
        # Проверяем, что файл создан и не пустой
        with open(tmp.name, encoding="utf-8") as f:
            data = f.read()
        os.remove(tmp.name)
        self.assertIn("W", data)
        self.assertIn("*", data)
        self.assertIn("TTTTT", data)

    def test_main_invalid_argument(self):
        """main() с нечисловым параметром должно завершиться ошибкой"""
        argv = ["abc", "output.txt"]
        captured = io.StringIO()
        sys_stdout_old, sys_stderr_old = sys.stdout, sys.stderr
        sys.stdout, sys.stderr = captured, captured
        with self.assertRaises(SystemExit):
            main(argv)
        sys.stdout, sys.stderr = sys_stdout_old, sys_stderr_old

    def test_main_wrong_args_count(self):
        """main() без аргументов должно выводить Usage"""
        captured = io.StringIO()
        sys_stdout_old, sys_stderr_old = sys.stdout, sys.stderr
        sys.stdout, sys.stderr = captured, captured
        with self.assertRaises(SystemExit):
            main([])
        sys.stdout, sys.stderr = sys_stdout_old, sys_stderr_old
        output = captured.getvalue()
        self.assertIn("python tree.py", output)


if __name__ == "__main__":
    unittest.main(verbosity=2)
